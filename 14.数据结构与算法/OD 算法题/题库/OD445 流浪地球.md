# 题目描述

流浪地球计划在赤道上均匀部署了 N 个转向发动机，按位置顺序编号为 0 ~ N

1. 初始状态下所有的发动机都是未启动状态
2. 发动机启动的方式分为“手动启动”和“关联启动”两种方式
3. 如果在时刻 1 一个发动机被启动，下一个时刻 2 与之相邻的两个发动机就会被“关联启动”
4. 如果准备启动某个发动机时，它已经被启动了，则什么都不用做
5. 发动机 0 与发动机 N-1 是相邻的

地球联合政府准备挑选某些发动机在某些时刻进行“手动启动”。当然最终所有的发动机都会被启动。哪些发动机最晚被启动呢？

# 输入描述

第一行两个数字 N 和 E，中间有空格

- N 代表部署发动机的总个数，1 < N ≤ 1000
- E 代表计划手动启动的发动机总个数，1 ≤ E ≤ 1000，E ≤ N

接下来共 E 行，每行都是两个数字 T 和 P，中间有空格

- T 代表发动机的手动启动时刻，0 ≤ T ≤ N
- P 代表次发动机的位置编号，0 ≤ P < N

# 输出描述

第一行一个数字 N， 以回车结束

- N 代表最后被启动的发动机个数

第二行 N 个数字，中间有空格，以回车结束

- 每个数字代表发动机的位置编号，从小到大排序

# 用例1

## 输入

```none
8 2
0 2
0 6
```

[Copy](javascript:;)

## 输出

```none
2
0 4
```

[Copy](javascript:;)

## 说明

> 8个发动机；
> 时刻0启动（2,6）;
> 时刻1启动（1,3,5,7）（其中1,3被2关联启动，5,7被6关联启动）；
> 时刻2启动（0,4）（其中0被1,7关联启动，4被3,5关联启动）；
> 至此所有发动机都被启动，最后被启动的有2个，分别是0和4。

# 答题

~~~javascript
const rl = require("readline").createInterface({ input: process.stdin });
const iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void (async function () {
  // n 是发动机总个数，e 是手动启动的发动机个数
  const [n, e] = (await readline()).split(" ").map(Number);
  // launches 数组表示每个发动机的发动时机，初始值为大于最大值的 1001，因为之后会遍历它进行比较，留下较小值
  const launches = new Array(n).fill(1001);
  // 将手动启动的时机更新到 launches 中
  for (let i = 0; i < e; i++) {
    // p 号发动机在 t 时刻手动启动
    const [t, p] = (await readline()).split(" ").map(Number);
    launches[p] = t;
  }

  // 从手动启动的发动机开始遍历，更新被关联启动的其他发动机的启动时机
  for (let i = 0; i < n; i++) {
    if (launches[i] === 1001) continue;
    // 更新被关联启动的其他发动机的启动时机
    for (let j = 0; j < n; j++) {
      // 被关联的发动机的启动时机相较于手动启动的间隔时间
      const innerInterval = Math.abs(i - j);
      const outerInterval = n - innerInterval;
      const interval = Math.min(innerInterval, outerInterval);

      // 更新关联启动的时机，如果其会在此之前被手动启动，则不更新
      launches[j] = Math.min(launches[j], launches[i] + interval);
    }
  }

  // 得到 launches 中的最大值，获取最终启动的发动机列表
  const maxT = launches.reduce((a, b) => Math.max(a, b));
  const last = [];
  for (let i = 0; i < n; i++) {
    if (launches[i] === maxT) last.push(i);
  }

  console.log(last.length);
  console.log(last.sort((a, b) => a - b).join(" "));
})();
~~~

